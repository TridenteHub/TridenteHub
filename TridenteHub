-- LocalScript (StarterGui) — Painel completo com Key + funções
local KEY_CORRETA = "2026ROUBEUMBRAINROT"
local LINK_KEY = "https://rekonise.com/key-script-x-roube-um-brainrot-dvdwv"
local DISCORD_LINK = "https://discord.gg/TzkuDUJrX6"
local TIKTOK_TEXT = "TIKTOK: @tridentehub"
local BY_TEXT = "By: @TridenteHub"

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local UIS = game:GetService("UserInputService")
local RS = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- RemoteEvent (deve existir no ReplicatedStorage — criado pelo ServerScript se não tiver)
local ToggleInvisEvent = ReplicatedStorage:WaitForChild("ToggleInvisEvent")

-- util notify
local function notify(title, text, dur)
    pcall(function()
        game.StarterGui:SetCore("SendNotification", {Title=title, Text=text, Duration = dur or 3})
    end)
end

-- verifica se GUI já existe e evita duplicar
if LocalPlayer:FindFirstChild("PlayerGui") and LocalPlayer.PlayerGui:FindFirstChild("SSX_Hub_GUI") then
    -- já existe; nada
else
    -- criar GUI
    local gui = Instance.new("ScreenGui")
    gui.Name = "SSX_Hub_GUI"
    gui.ResetOnSpawn = false
    gui.Parent = LocalPlayer:WaitForChild("PlayerGui")

    -- main frame
    local frame = Instance.new("Frame", gui)
    frame.Name = "MainFrame"
    frame.Size = UDim2.new(0,420,0,480)
    frame.Position = UDim2.new(0.5,-210,0.5,-240)
    frame.BackgroundColor3 = Color3.fromRGB(30,30,30)
    frame.Active = true
    frame.Draggable = true
    frame.BorderSizePixel = 0

    -- title + tiktok
    local title = Instance.new("TextLabel", frame)
    title.Size = UDim2.new(1,0,0,60)
    title.Position = UDim2.new(0,0,0,0)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.GothamBold
    title.TextSize = 24
    title.TextColor3 = Color3.new(1,1,1)
    title.Text = "SSX Hub - Painel\n" .. TIKTOK_TEXT

    -- subtitle (discord button area)
    local discordBtn = Instance.new("TextButton", frame)
    discordBtn.Size = UDim2.new(0.9,0,0,40)
    discordBtn.Position = UDim2.new(0.05,0,0,60)
    discordBtn.BackgroundColor3 = Color3.fromRGB(0,120,225)
    discordBtn.Font = Enum.Font.GothamBold
    discordBtn.TextSize = 18
    discordBtn.TextColor3 = Color3.new(1,1,1)
    discordBtn.Text = "Atualizações do script no Discord (Clique para copiar link)\n" .. BY_TEXT

    discordBtn.MouseButton1Click:Connect(function()
        if setclipboard then
            setclipboard(DISCORD_LINK)
            notify("Discord", "Link copiado para o clipboard", 3)
        else
            notify("Discord", "setclipboard não disponível", 3)
        end
    end)

    -- container de botões (vertical)
    local container = Instance.new("Frame", frame)
    container.Size = UDim2.new(0.9,0,0,300)
    container.Position = UDim2.new(0.05,0,0,110)
    container.BackgroundTransparency = 1

    local function criarBotao(text, y)
        local b = Instance.new("TextButton", container)
        b.Size = UDim2.new(1,0,0,48)
        b.Position = UDim2.new(0,0,0,y)
        b.BackgroundColor3 = Color3.fromRGB(45,45,45)
        b.Font = Enum.Font.GothamBold
        b.TextSize = 18
        b.TextColor3 = Color3.new(1,1,1)
        b.Text = text
        return b
    end

    -- estado das funções
    local state = {
        infJump = false,
        god = false,
        noclip = false,
        desync = false,
        xray = false,
        invisAll = false, -- server-side invisibility (for all)
    }

    -- Jump+God integrados
    local btnInfJump = criarBotao("Inf Jump: OFF", 0)
    local btnGod = criarBotao("God (paired with Jump): OFF", 1 * 48 + 8)
    btnInfJump.MouseButton1Click:Connect(function()
        state.infJump = not state.infJump
        btnInfJump.Text = state.infJump and "Inf Jump: ON" or "Inf Jump: OFF"
        -- if enabling jump and god pairing, also enable god
        if state.infJump and not state.god then
            state.god = true
            btnGod.Text = "God (paired with Jump): ON"
        end
    end)
    btnGod.MouseButton1Click:Connect(function()
        state.god = not state.god
        btnGod.Text = state.god and "God (paired with Jump): ON" or "God (paired with Jump): OFF"
        -- if enabling god and infJump not on, keep them independent; we'll keep god active regardless
    end)

    -- re-aplica god/infinite jump em respawn
    local function applyGodToCharacter(char)
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        if hum and state.god then
            hum.Health = hum.MaxHealth
            -- conecta sinal para manter saúde
            local conn
            conn = hum:GetPropertyChangedSignal("Health"):Connect(function()
                if state.god and hum and hum.Health < hum.MaxHealth then
                    hum.Health = hum.MaxHealth
                elseif not state.god and conn then
                    conn:Disconnect()
                end
            end)
        end
    end

    -- JumpRequest
    UIS.JumpRequest:Connect(function()
        if state.infJump then
            local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if hum then hum:ChangeState(Enum.HumanoidStateType.Jumping) end
        end
    end)

    -- God reapply on spawn
    LocalPlayer.CharacterAdded:Connect(function(char)
        task.wait(0.5)
        applyGodToCharacter(char)
        -- reapply noclip and desync visuals if active
        if state.noclip then
            -- small delay to ensure parts exist
            task.delay(0.2, function()
                for _, p in ipairs(char:GetDescendants()) do
                    if p:IsA("BasePart") and p.Name ~= "HumanoidRootPart" then
                        p.CanCollide = false
                    end
                end
            end)
        end
        if state.desync then
            -- if we previously hid local parts, re-hide them locally
            task.delay(0.2, function()
                for _, part in ipairs(char:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.LocalTransparencyModifier = 1
                    end
                end
            end)
        end
    end)

    -- Desync Body (local invis + use clone if present)
    local btnDesync = criarBotao("Desync Body (usar clone)", 2 * 48 + 16)
    local currentDesyncClone = nil
    btnDesync.MouseButton1Click:Connect(function()
        -- show small loading text
        btnDesync.Text = "Carregando..."
        task.spawn(function()
            -- procura clone no Backpack ou StarterPack
            local backpack = LocalPlayer:FindFirstChildOfClass("Backpack")
            local candidate = nil
            if backpack then
                for _, item in ipairs(backpack:GetChildren()) do
                    if item:IsA("Tool") or item:IsA("Model") then
                        local n = item.Name:lower()
                        if n:find("clone") or n:find("body") or n:find("desync") or n:find("model") then
                            candidate = item
                            break
                        end
                    end
                end
            end
            if not candidate then
                local sp = game:GetService("StarterPack")
                for _, item in ipairs(sp:GetChildren()) do
                    if item:IsA("Tool") or item:IsA("Model") then
                        local n = item.Name:lower()
                        if n:find("clone") or n:find("body") or n:find("desync") or n:find("model") then
                            candidate = item
                            break
                        end
                    end
                end
            end
            task.wait(0.6)
            if not candidate then
                btnDesync.Text = "Desync Body (usar clone)"
                notify("Desync Body", "Clone não encontrado no inventário", 4)
                return
            end
            -- use candidate: clone and place near player (local only)
            local ok, err = pcall(function()
                local cloned = candidate:Clone()
                cloned.Parent = workspace
                cloned:SetPrimaryPartCFrame((LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character.HumanoidRootPart.CFrame) or CFrame.new())
                currentDesyncClone = cloned
                -- make local player invisible locally
                local char = LocalPlayer.Character
                if char then
                    for _, p in ipairs(char:GetDescendants()) do
                        if p:IsA("BasePart") then
                            p.LocalTransparencyModifier = 1
                        end
                    end
                end
                state.desync = true
                btnDesync.Text = "Desync: ON (clonado)"
                notify("Desync Body", "Desync aplicado (local).", 4)
            end)
            if not ok then
                btnDesync.Text = "Desync Body (usar clone)"
                notify("Desync Body", "Erro ao clonar: "..tostring(err), 4)
            end
        end)
    end)

    -- botão para reverter desync (se quiser)
    local btnDesyncOff = criarBotao("Reverter Desync", 3 * 48 + 24)
    btnDesyncOff.MouseButton1Click:Connect(function()
        if currentDesyncClone and currentDesyncClone.Parent then
            pcall(function() currentDesyncClone:Destroy() end)
            currentDesyncClone = nil
        end
        local char = LocalPlayer.Character
        if char then
            for _, p in ipairs(char:GetDescendants()) do
                if p:IsA("BasePart") then
                    p.LocalTransparencyModifier = 0
                end
            end
        end
        state.desync = false
        btnDesync.Text = "Desync Body (usar clone)"
        notify("Desync Body", "Revertido", 3)
    end)

    -- Fly to Base (procura "Base de <seuNome>" TextLabel e vai ao teto, depois desce até parte 'venda')
    local btnFly = criarBotao("Fly to My Base", 4 * 48 + 32)
    local function encontrarMinhaBase()
        local meuNome = LocalPlayer.Name
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("TextLabel") and obj.Text:lower():find("base de") then
                local dono = obj.Text:match("Base de%s*(.*)")
                if dono and dono:lower() == meuNome:lower() then
                    -- retorna model pai mais próximo
                    local mdl = obj
                    while mdl and not mdl:IsA("Model") do
                        mdl = mdl.Parent
                    end
                    if mdl then return mdl end
                end
            end
        end
        return nil
    end

    local function encontrarParteVenda(baseModel)
        if not baseModel then return nil end
        for _, obj in ipairs(baseModel:GetDescendants()) do
            if obj:IsA("BasePart") then
                local name = obj.Name:lower()
                if name:find("vende") or name:find("venda") or name:find("vendedor") or name:find("seller") or name:find("sell") then
                    return obj
                end
            end
        end
        -- fallback: primeiro BasePart
        for _, obj in ipairs(baseModel:GetDescendants()) do
            if obj:IsA("BasePart") then return obj end
        end
        return nil
    end

    btnFly.MouseButton1Click:Connect(function()
        local base = encontrarMinhaBase()
        if not base then
            notify("Fly to Base", "Sua base não foi encontrada!", 4)
            return
        end
        -- find highest part (top)
        local topPart
        local topY = -math.huge
        for _, p in ipairs(base:GetDescendants()) do
            if p:IsA("BasePart") then
                if p.Position.Y > topY then
                    topY = p.Position.Y
                    topPart = p
                end
            end
        end
        local vendaPart = encontrarParteVenda(base)
        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then notify("Fly to Base", "HRP não encontrado", 4); return end
        if topPart then
            local above = topPart.Position + Vector3.new(0, 8, 0)
            local tw = TweenService:Create(hrp, TweenInfo.new(1.2, Enum.EasingStyle.Quad), {CFrame = CFrame.new(above)})
            tw:Play(); tw.Completed:Wait()
            task.wait(0.25)
            if vendaPart then
                local down = vendaPart.Position + Vector3.new(0,3,0)
                local tw2 = TweenService:Create(hrp, TweenInfo.new(1.0, Enum.EasingStyle.Quad), {CFrame = CFrame.new(down)})
                tw2:Play()
                notify("Fly to Base", "Indo até area de venda", 4)
            else
                notify("Fly to Base", "Parte de venda não encontrada; posicionado acima do teto", 4)
            end
        else
            notify("Fly to Base", "TopPart não encontrado", 4)
        end
    end)

    -- 3rd Floor (cria plataforma)
    local btn3rd = criarBotao("3rd Floor (spawn platform)", 5 * 48 + 40)
    local platform = nil
    btn3rd.MouseButton1Click:Connect(function()
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then notify("3rd Floor","HRP não encontrado",3); return end
        if platform and platform.Parent then pcall(function() platform:Destroy() end) end
        platform = Instance.new("Part", workspace)
        platform.Name = "SSX_3rdFloor_Platform"
        platform.Size = Vector3.new(8,0.6,8)
        platform.Anchored = true
        platform.CanCollide = true
        platform.Transparency = 0.25
        platform.CFrame = hrp.CFrame * CFrame.new(0, -3.5, 0)
        notify("3rd Floor", "Plataforma criada",3)
    end)

    -- X-Ray Base (local change to parts transparency + highlight brainrots)
    local btnXray = criarBotao("X-Ray Base: OFF", 6 * 48 + 48)
    local xrayOriginals = {}
    btnXray.MouseButton1Click:Connect(function()
        state.xray = not state.xray
        btnXray.Text = state.xray and "X-Ray Base: ON" or "X-Ray Base: OFF"
        if state.xray then
            -- salvar e aplicar
            xrayOriginals = {}
            for _, m in ipairs(workspace:GetDescendants()) do
                if m:IsA("Model") and m.Name:lower():find("base") then
                    for _, p in ipairs(m:GetDescendants()) do
                        if p:IsA("BasePart") then
                            xrayOriginals[p] = p.Transparency
                            p.Transparency = math.clamp(p.Transparency + 0.5,0,0.9)
                        end
                    end
                end
            end
            -- highlights brainrots
            for _, obj in ipairs(workspace:GetDescendants()) do
                if obj:IsA("BasePart") and obj.Name:lower():find("brainrot") then
                    if not obj:FindFirstChild("BR_Highlight") then
                        local hl = Instance.new("Highlight")
                        hl.Name = "BR_Highlight"
                        hl.Adornee = obj
                        hl.Parent = obj
                        hl.FillColor = Color3.fromRGB(255,180,0)
                        hl.OutlineColor = Color3.new(1,1,1)
                        hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                    end
                end
            end
            notify("X-Ray", "Aplicado",3)
        else
            -- restaurar
            for p, orig in pairs(xrayOriginals) do
                if p and p.Parent then p.Transparency = orig end
            end
            xrayOriginals = {}
            for _, h in ipairs(workspace:GetDescendants()) do
                if h:IsA("Highlight") and h.Name == "BR_Highlight" then
                    pcall(function() h:Destroy() end)
                end
            end
            notify("X-Ray", "Restaurado",3)
        end
    end)

    -- Noclip (local)
    local btnNoclip = criarBotao("Noclip: OFF", 7 * 48 + 56)
    btnNoclip.MouseButton1Click:Connect(function()
        state.noclip = not state.noclip
        btnNoclip.Text = state.noclip and "Noclip: ON" or "Noclip: OFF"
        local char = LocalPlayer.Character
        if state.noclip and char then
            -- connect Stepped and store connection
            if not btnNoclip:FindFirstChild("Conn") then
                local conn = RS.Stepped:Connect(function()
                    local ch = LocalPlayer.Character
                    if ch then
                        for _, p in ipairs(ch:GetDescendants()) do
                            if p:IsA("BasePart") and p.Name ~= "HumanoidRootPart" then
                                p.CanCollide = false
                            end
                        end
                    end
                end)
                btnNoclip:SetAttribute("Conn", true)
                btnNoclip:SetAttribute("connRef", true)
                -- store in state so we can disconnect later
                state._noclipConn = conn
            end
        else
            -- disconnect
            if state._noclipConn then
                pcall(function() state._noclipConn:Disconnect() end)
                state._noclipConn = nil
            end
            -- restore collisions on character
            local ch = LocalPlayer.Character
            if ch then
                for _, p in ipairs(ch:GetDescendants()) do
                    if p:IsA("BasePart") then
                        p.CanCollide = true
                    end
                end
            end
        end
    end)

    -- Server-side invisibility for ALL (uses RemoteEvent) - allowed because game is yours
    local btnInvisAll = criarBotao("Make me invisible to ALL: OFF", 8 * 48 + 64)
    btnInvisAll.MouseButton1Click:Connect(function()
        state.invisAll = not state.invisAll
        btnInvisAll.Text = state.invisAll and "Make me invisible to ALL: ON" or "Make me invisible to ALL: OFF"
        -- pede ao servidor para aplicar (servidor valida Owner)
        pcall(function()
            ToggleInvisEvent:FireServer(state.invisAll)
            notify("Invisibility", "Pedido enviado ao servidor", 3)
        end)
    end)

    -- ESP Best Brainrot list (procura objetos 'brainrot' e mostra nome / valor / raridade)
    local btnListBR = criarBotao("ESP Best Brainrot (listar)", 9 * 48 + 72)
    local brListFrame = Instance.new("ScrollingFrame", frame)
    brListFrame.Size = UDim2.new(0.9,0,0,120)
    brListFrame.Position = UDim2.new(0.05,0,0, 9 * 48 + 72 + 56)
    brListFrame.CanvasSize = UDim2.new(0,0,0,0)
    brListFrame.BackgroundTransparency = 1
    brListFrame.Visible = false

    local function scanBrainrots()
        local results = {}
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("BasePart") and obj.Name:lower():find("brainrot") then
                -- tenta ler valor (procura NumberValue ou Attribute "value")
                local val = nil
                if obj:FindFirstChild("Value") and obj.Value and type(obj.Value.Value) == "number" then
                    val = obj.Value.Value
                elseif obj:GetAttribute("value") then
                    val = obj:GetAttribute("value")
                end
                local rarity = "Common"
                if obj:GetAttribute("rarity") then
                    rarity = obj:GetAttribute("rarity")
                end
                table.insert(results, {part = obj, name = obj.Name, value = val or 0, rarity = rarity})
            end
        end
        table.sort(results, function(a,b) return (a.value or 0) > (b.value or 0) end)
        return results
    end

    local function showBrainrotList()
        brListFrame:ClearAllChildren()
        local list = scanBrainrots()
        local y = 0
        for i,entry in ipairs(list) do
            local t = Instance.new("TextLabel", brListFrame)
            t.Size = UDim2.new(1,0,0,24)
            t.Position = UDim2.new(0,0,0,y)
            t.BackgroundTransparency = 1
            t.TextColor3 = Color3.new(1,1,1)
            t.Font = Enum.Font.Gotham
            t.TextSize = 16
            t.Text = (entry.name or "Brainrot") .. "  -  $" .. tostring(entry.value) .. "  [" .. tostring(entry.rarity) .. "]"
            y = y + 24
        end
        brListFrame.CanvasSize = UDim2.new(0,0,0,y)
        brListFrame.Visible = true
    end

    btnListBR.MouseButton1Click:Connect(function()
        if brListFrame.Visible then
            brListFrame.Visible = false
        else
            showBrainrotList()
            brListFrame.Visible = true
        end
    end)

    -- circular blue minimizer (botão flutuante no canto) - quando minimiza o frame vira um círculo azul
    local circleBtn = Instance.new("ImageButton", gui)
    circleBtn.Name = "CircleMin"
    circleBtn.Size = UDim2.new(0,64,0,64)
    circleBtn.Position = UDim2.new(1,-90,0,20)
    circleBtn.AnchorPoint = Vector2.new(1,0)
    circleBtn.Image = "" -- vazio, cor usaremos BackgroundColor
    circleBtn.BackgroundColor3 = Color3.fromRGB(0,120,255)
    circleBtn.AutoButtonColor = true
    circleBtn.ZIndex = 100
    circleBtn.Rotation = 0
    circleBtn.BorderSizePixel = 0
    circleBtn.Visible = true

    -- make it round
    local uiCorner = Instance.new("UICorner", circleBtn)
    uiCorner.CornerRadius = UDim.new(0,32)

    local minimizedCircle = false
    circleBtn.MouseButton1Click:Connect(function()
        minimizedCircle = not minimizedCircle
        if minimizedCircle then
            -- animate frame to small and hide children, then show circle (already visible)
            TweenService:Create(frame, TweenInfo.new(0.25), {Size = UDim2.new(0,80,0,80), Position = UDim2.new(0.5,-40,0.5,-40)}):Play()
            task.delay(0.25, function()
                for _, v in ipairs(frame:GetChildren()) do
                    if v ~= title then
                        v.Visible = false
                    end
                end
            end)
            circleBtn.BackgroundColor3 = Color3.fromRGB(0,120,255)
        else
            -- restore
            TweenService:Create(frame, TweenInfo.new(0.25), {Size = UDim2.new(0,420,0,480), Position = UDim2.new(0.5,-210,0.5,-240)}):Play()
            task.delay(0.25, function()
                for _, v in ipairs(frame:GetChildren()) do
                    v.Visible = true
                end
            end)
        end
    end)

    -- ensure circle draggable? user wanted circle fully blue; let's allow drag
    circleBtn.Active = true
    circleBtn.Draggable = true

    -- final notice
    notify("SSX Hub", "Painel carregado. Key: " .. KEY_CORRETA, 4)
end
